# Econ Sim: Simulador de Modelos Econ√≥micos y Mercados

## üìÖ √çndice

1. [Resumen del Proyecto](#1-resumen-del-proyecto)
2. [Modelos de la Simulaci√≥n](#2-modelos-de-la-simulaci√≥n)

   * [2.1 POP](#21-pop)

     * [2.1.1 Personalidad](#211-personalidad)
     * [2.1.2 Necesidades](#212-necesidades)
   * [2.2 Bien](#22-bien)

     * [2.2.1 Bienes transables](#221-bienes-transables)
     * [2.2.2 Bienes no transables](#222-bienes-no-transables)
   * [2.3 Empresa](#23-empresa)
   * [2.4 Regi√≥n](#24-regi√≥n)
   * [2.5 Mercado](#25-mercado)
3. [Flujo de la Simulaci√≥n](#3-flujo-de-la-simulaci√≥n)

   * [3.1 Flujo del tiempo en la simulaci√≥n y coordinaci√≥n entre POPs y empresas](#31-flujo-del-tiempo-en-la-simulaci√≥n-y-coordinaci√≥n-entre-pops-y-empresas)
4. [Arquitectura del Proyecto](#4-arquitectura-del-proyecto)

   * [4.1 Estructuras (Structures)](#41-estructuras-structures)
   * [4.2 L√≥gica Central (Service)](#42-l√≥gica-central-service)
   * [4.3 Interfaz de Usuario (UI)](#43-interfaz-de-usuario-ui)
   * [4.4 Aplicaci√≥n (Application)](#44-aplicaci√≥n-application)
   * [4.5 Persistencia de Datos (Repository)](#45-persistencia-de-datos-repository)
   * [4.6 Testing](#46-testing)
   * [4.7 Flujo de Datos entre Capas](#47-flujo-de-datos-entre-capas)
   * [4.8 Aclaraciones](#48-aclaraciones)
5. [C√≥mo Compilar y Ejecutar el Programa](#5-como-compilar-y-ejecutar-el-programa)

   * [5.1 Compilaci√≥n y limpieza](#51-compilaci√≥n-y-limpieza)
   * [5.2 Ejecuci√≥n](#52-ejecuci√≥n)
6. [Estrategia de Testing](#6-estrategia-de-testing)

   * [6.1 Testing unitario y de integraci√≥n](#61-testing-unitario-y-de-integraci√≥n)
   * [6.2 Testing de memoria](#62-testing-de-memoria)
   * [6.3 Testing de performance](#63-testing-de-performance)
   * [6.4 Compilaci√≥n de los test](#64-compilaci√≥n-de-los-test)
   * [6.5 Ejecuci√≥n de los test](#65-ejecuci√≥n-de-los-test)

## 1. Resumen del Proyecto

**Objetivo:**
El proyecto "Econ Sim" tiene como prop√≥sito simular modelos econ√≥micos y din√°micas de mercado a partir de la interacci√≥n de grupos de poblaci√≥n que producen, consumen e intercambian bienes para satisfacer sus necesidades y generar ganancias.
El objetivo del proyecto es poder derivar conclusiones macroeconomicas basadas en interacciones microeconomicas entre agentes con personalidades distintas que definan su comportamiento esperado.

---

## 2. Modelos de la Simulaci√≥n

### 2.1 POP
- **Descripcion**
  Representa a grupos de poblaci√≥n con caracteristicas similares. Los mismos comparten:
  - Personalidad
  - Lugar de residencia
  - Lugar de trabajo (Empresa)
  - Profesi√≥n
  Cada POP tiene una cantidad determinada de poblaci√≥n la cual puede fluctuar durante la simulaci√≥n.

#### 2.1.1 Personalidad
- **Descripcion**
  Representa el conjunto de atributos que posee una POP que lo diferencian del resto respecto a sus preferencias
  - Determina las necesidades
  - Determina la propensi√≥n al consumo
  - Determina la propensi√≥n a la procreaci√≥n

#### 2.1.2 Necesidades
- **Descripcion**
  Una necesidad es una caracteristica de la personalidad que determina el deseo de una POP de consumir determinada cantidad de ciertos bienes.
- **Formas de cubrirlas**
  Cada necesidad se cubre con una cierta cantidad de alg√∫n bien dentro de un grupo de bienes.
  Por ejemplo:
  - Hambre: verduras, carne, queso, etc
  - Vestimenta: ropa simple, ropa de lujo, etc

### 2.2 Bien
- **Descripci√≥n:**  
  Representa cada elemento producido y consumido por las POPs.  
- **Din√°mica de Precios:**  
  Cada bien tiene un precio que fluct√∫a en cada jornada seg√∫n la oferta y la demanda registradas en el mercado. La proporcion en la que esto ocurre por cada unidad del bien comerciado se deriva del promedio de las personalidades de todas las POPs (esto es, la funcion de elasticidad de cada bien va a depender de las preferencias de cada uno de los consumidores)
#### 2.2.1 Bienes transables
Representan aquellos que pueden ser comercializados entre regiones (materias primas, comida, vestimenta, etc)
#### 2.2.2 Bienes no transables
Son los que solo se pueden comerciar dentro de una region (transporte, educacion, salud, etc)

### 2.3 Empresa
- **Descripci√≥n:**  
  Es el modelo que se encarga de coordinar la producci√≥n de bienes. Utiliza bienes intermedios, materia prima y mano de obra para llevar a cabo la producci√≥n.
  La funcion de costos de la empresa depende de la mano de obra que utilicen, de la proporci√≥n de bienes y del capital utlizado en la producci√≥n.
- **Empresas intermediarias**
  Son aquellas que manejan el comercio entre regiones (se explica de forma m√°s extensa en el apartado 2.5). Cualquier empresa puede volverse intermediaria si lo considera rentable.

### 2.4 Regi√≥n
- **Descripci√≥n:** 
Las regiones son los lugares fisicos donde ocurre la producci√≥n, donde viven las POPs y de donde se extraen los bienes primarios. Adem√°s, las regiones tienen distancias definidas entre s√≠ que pueden afectar la eficiencia del comercio.

### 2.5 Mercado
- **Descripci√≥n:**  
  Espacio de intercambio donde las POPs y empresas pueden adquirir bienes y ofertar sus productos. El mercado dispone los bienes dados por las empresas y POPs y les permite acceder a ellos a trav√©s del comercio. Existe un mercado por regi√≥n.
- **Rol:**  
  Opera como interfaz intermedia y regula las transacciones, guardando informaci√≥n necesaria para el ajuste de precios.
- **Existencia de empresas intermediarias**
  Como en una misma region todo el comercio se regula mediante un solo mercado, la existencia de empresas intermediarias a nivel local no tiene sentido. Para manejar el comercio entre regiones existen empresas intermediarias que comercian bienes entre regiones, llevando bienes de una region a otra como parte de sus tareas. Sin embargo, el comercio entre regiones tiene costos extra de transporte (que a su vez dependen de los bienes de transporte disponibles en el mercado).
---

## 3. Flujo de la Simulaci√≥n

1. **Inicio de la Jornada:**
   - Una POP inicia un nuevo d√≠a identificando las necesidades que debe satisfacer.
2. **Revisi√≥n de Recursos:**
   - La POP verifica los bienes que posee y que pueden cubrir sus necesidades.
3. **Producci√≥n o Trabajo:**
   - La POP comienza su d√≠a laboral asistiendo a la empresa donde trabaja. All√≠ se le proveen los bienes y herramientas necesarios para llevar a cabo dicha producci√≥n. Una vez que termina de producir, se le paga la remuneraci√≥n acordada.
4. **Operaciones de Mercado:**
   - Una vez finalizada la jornada laboral, la empresa vende los bienes producidos en el mercado.
   - La POP puede optar por vender bienes en su posesi√≥n si necesitara recursos extra.
   - Las empresas proceden a comprar los bienes necesarios para la producci√≥n del d√≠a siguiente (seg√∫n la producci√≥n esperada y los recursos disponibles), y las POPs los bienes necesarios para cubrir sus necesidades. La cantidad adquirida depender√° de la personalidad de la POP y de los recursos que posea
5. **Iteraci√≥n:**
   - La jornada concluye y se inicia el siguiente ciclo, ajustando los precios de los bienes seg√∫n la nueva oferta y demanda y las elasticidades de cada bien particular.

> **Nota:** El precio de cada bien es din√°mico y se regula en funci√≥n de las interacciones de oferta y demanda durante cada jornada. Los precios ademas son locales al mercado de cada regi√≥n.

### 3.1 Flujo del tiempo en la simulaci√≥n y coordinaci√≥n entre POPs y empresas
Cada iteraci√≥n corresponde a una jornada. Dentro de cada jornada, las POPs deben realizar 3 tareas
 - Cubrir sus necesidades
 - Trabajar
 - Comerciar
Cubrir sus necesidades y trabajar son dos tipos de operaciones que las POPs pueden realizar en paralelo (ya que no dependen de otras POPs para hacerlo), por lo que se calcularan en paralelo.
Comerciar es una actividad que requiere varias etapas:
 - Llevar los bienes al mercado
 - Reconocer qu√© bienes hay en el mercado
 - Comprar los bienes necesarios
Adem√°s, el stock de bienes no es infinito, por lo que habr√° bienes que ciertas POPs o empresas puedan adquirir y que otras no, por lo que las √∫ltimas dos etapas representan un desaf√≠o interesante si queremos evitar linealizar el procesamiento de la etapa de comercio.
En este sentido, la tarea de llevar los bienes al mercado se puede paralelizar. Una vez el mercado tiene todo el stock disponible, los agentes (POPs y empresas) pueden comenzar a comerciar. Para ello, se establecer√° un orden aleatorio en el que los agentes acceden al mercado (para garantizar equidad de acceso en el largo plazo) y cada agente comprar√° los bienes que necesite en 3 etapas (esto evita que los agentes con mayor propensi√≥n al consumo dejen sin bienes al resto, en caso de escasez significativa. El n√∫mero 3 es arbitrario).

---

## 4. Arquitectura del Proyecto

Dado que se opta por desarrollar desde cero en C, siendo un lenguaje de bajo nivel, es fundamental una buena organizaci√≥n del c√≥digo. Para ello, se ha planteado una arquitectura modular por capas:

### 4.1 Estructuras (Structures)
- **Funci√≥n:**  
  Define y agrupa las estructuras de datos utilizadas en la simulaci√≥n.
- **Importancia:**  
  Facilita la reutilizaci√≥n y el mantenimiento del c√≥digo subyacente.

### 4.2 L√≥gica Central (Service)
- **Funci√≥n:**  
  Implementa la l√≥gica principal del programa, basada en los modelos descritos en el apartado anterior.
- **Responsabilidad:**  
  Efect√∫a los c√°lculos y establece las reglas que rigen la simulaci√≥n.

### 4.3 Interfaz de Usuario (UI)
- **Funci√≥n:**  
  Se encarga de la presentaci√≥n y visualizaci√≥n de los datos generados por la simulaci√≥n.
- **Enfoque:**  
  Asegura que el usuario final tenga acceso a informaci√≥n clara y precisa sobre el estado y evoluci√≥n del sistema.

### 4.4 Aplicaci√≥n (Application)
- **Funci√≥n:**  
  Act√∫a como una capa intermediaria entre la l√≥gica de negocio (Service) y la interfaz de usuario (UI).
- **Responsabilidades:**
  - Gestionar y mantener el estado global de la simulaci√≥n.
  - Coordinar el flujo de datos entre las diferentes capas.
  - Facilitar la comunicaci√≥n bidireccional (por ejemplo, enviar datos calculados al UI y recibir el estado actualizado para la siguiente iteraci√≥n).

### 4.5 Persistencia de Datos (Repository)
- **Funci√≥n:**  
  Define los contratos y la l√≥gica de persistencia, permitiendo guardar y recuperar el estado de la simulaci√≥n.
- **Aplicaci√≥n:**  
  Se encarga de almacenar registros en archivos, lo cual es crucial para el an√°lisis y la trazabilidad de la simulaci√≥n.

### 4.6 Testing
- **Funcion**
  Asegurar que todos los modulos funcionen correctamente
- **Tipos de testing**
  Los test unitarios se definen dentro de cada m√≥dulo en un archivo (modulo).test.c (con su correspondiente header). Los test de integraci√≥n se definen en la capa de testing general
- **Importancia**
  Asegura que cada una de las partes del proyecto, y el proyecto en su conjunto, funcionen como se espera.

### 4.7 Flujo de Datos entre Capas
- **Service ‚Üí Application:**  
  El m√≥dulo Service calcula los datos y los transmite a Application.
- **Application ‚Üí UI:**  
  La capa Application env√≠a los datos pertinentes a la UI para su visualizaci√≥n.
- **Application ‚Üí Repository:**  
  Application comunica los datos a la capa Repository para guardarlos de manera persistente.
- **Application ‚Üí Service:**  
  La capa Application retroalimenta el estado actualizado al Service para permitir el c√°lculo de la siguiente iteraci√≥n.

### 4.8 Aclaraciones
- Las implementaciones especificas que se hagan en cada capa no se detallan en la documentaci√≥n ya que la idea es que distintas implementaciones sean aplicables y se puedan reemplazar sin afectar al resto de capas

---

## 5. Como compilar y ejecutar el programa

### 5.1 Compilaci√≥n y limpieza
Compilamos ejecutando el siguiente comando en una consola
```bash
make
```
Esto nos generar√° un ejecutable. Para eliminar los archivos .o ejecutamos
```bash
make clean
```
### 5.2 Ejecuci√≥n
Si queremos correr el programa directamente, ejecutamos
```bash
make run
```
Esto adem√°s limpiar√° los archivos .o

## 6. Estrategia de testing
### 6.1 Testing unitario y de integraci√≥n
Se generar√°n archivos con extensi√≥n .test.c (con sus respectivos headers) los cuales contengan funciones de testing para cada uno de los modulos. mediante un archivo (type).test.c  (donde type es unit o integration) se ejecutar√°n de forma centralizada todos los test a la vez.
Los test deber√°n generar una salida a un archivo de texto con los logs de todos los test que hayan fallado, junto con una estadistica general (total de tests, tests exitosos, tests fallidos)
Para generar la salida de los test que fallan, se utilizar√°n macros similares a assert que den informaci√≥n extra, por ejemplo
```C
#include <stdio.h>
#include <stdlib.h>

#define MY_ASSERT(expr, msg) do { \
    if (!(expr)) { \
        fprintf(stderr, "Assertion failed: %s\nFile: %s, Line: %d - %s\n", #expr, __FILE__, __LINE__, msg); \
        return 1; \
    } \
} while (0)

```
### 6.2 Testing de memoria
Se utilizar√° Valgrind para corroborar que no ocurran leaks de memoria durante la ejecuci√≥n del programa.
Se automatizar√° su uso mediante scripts de bash para ejecutar y analizar mas eficientemente la salida brindada por valgrind. Dichas salidas se guardaran en archivos de log para su posterior an√°lisis
### 6.3 Testing de performance
Se utilizar√° una estrategia similar a la del punto 6.2, pero con el uso de funciones como clock() para medir el tiempo de ejecuci√≥n de ciertas funciones cr√≠ticas.
### 6.4 Compilaci√≥n de los test
Se utilizar√° un makefile para los test unitarios y uno para los test de integraci√≥n.
### 6.5 Ejecuci√≥n de los test
Un script de bash se utilizar√° para realizar las siguientes tareas en orden
1. Compilar todos los test
2. Ejecutar tests unitarios
3. Ejecutar tests de integraci√≥n
4. Ejecutar tests de memoria
5. Ejecutar tests de performance
6. Recopilar toda la informaci√≥n en un archivo de resumen con formato adecuado

## Materias pendientes
En esta secci√≥n se detallan cuestiones importantes que faltan definir para la implementaci√≥n del proyecto.
### 1 Manejo de errrores
Definir una estrategia de manejo de errores dentro del programa.
### 2 Logging
Definir una implementaci√≥n de logs (preferiblemente en archivos) para recopilar informaci√≥n interna importante de la ejecuci√≥n del programa.
### 3 Manejo de memoria
Definir explicitamente cual es el patron por el cual se va a manejar la memoria dentro del proyecto.
### 4 Definici√≥n de interfaces de modelos
Definir los m√©todos y parametros que va a utilizar cada modelo descrito en la secci√≥n 2, adem√°s de las interfaces a usar para comunicarse con los otros modelos.
### 5 Definici√≥n de interfaces de capas
Definir c√≥mo van a interactuar las distintas capas entre s√≠ para garantizar la intercambiabilidad de m√≥dulos de ser necesario.
### 7 Definici√≥n de un apartado de configuraci√≥n y parametrizaci√≥n general
Se requiere un apartado que detalle ciertos parametros como la cantidad de agentes y bienes, los rangos de precios, o los valores que determinan las necesidades, y que explique la raz√≥n detr√°s de los mismos, adem√°s de proyecciones de c√≥mo podr√≠an cambiar en el tiempo (ejemplo, se puede empezar con 3 bienes para testear una version inicial del modelo y ampliar ese n√∫mero lo m√°ximo posible con el tiempo).
### 9 Detalle de posibles implementaciones particulares de UI y capa de persistencia
Describir c√≥mo se mostrar√°n los datos al usuario y c√≥mo se van a guardar.
### 10 Definici√≥n de un men√∫ de control para toda la app
Describir un flujo externo a la simulaci√≥n que nos permita cargar otras simulaciones previas, borrarlas, etc. Esto ademas implica la definici√≥n de estrategias especificas de configuracion de simulaciones para parametrizarlas.
### 11 Diagrama de alto nivel
Un UML de componentes o un diagrama de secuencia para el flujo de una jornada ayudar√≠a a visualizar la interacci√≥n entre agentes y capas.
### 12 Gesti√≥n de concurrencia
Definir una estrategia de gesti√≥n de concurrencia e hilos (si aplica)
### 13 Roadmap
Definir el flujo de desarrollo por etapas esperado para facilitar el desarrollo en el tiempo y evitar bloqueos.
### 14 Definir estandares de estilo codigo
Idioma en el que se programa (preferiblemente ingles), que tipo de notacion para variables, funciones y constantes se usa (preferiblemente usar snake_case para variables y funciones en UPPER_SNAKE_CASE)
### 16 Definir c√≥mo se comportar√°n las funciones de costos de las empresas
Idealmente, esta funci√≥n no debe tener "numeros m√°gicos", sino que debe derivar su funcionamiento de variables esenciales dentro de la simulaci√≥n
---